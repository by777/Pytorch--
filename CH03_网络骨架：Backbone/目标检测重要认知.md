[参考连接]: https://www.zhihu.com/zvideo/1356732245315805184



# Backbone、neck和head

在One-Stage Anchor free的检测器中，我们习惯性的将整个网络划分为3个部分：`backbone` 、`neck`和`head`。

## backbone: VGG\ResNet\ResNeXt\EfficientNet

每一个被选择特征图都有内在固有的语义表达能力。即：使用这个特征图做后面的预测，它到底能学什么、能学多好，可能就已经内定了。

特征图上每个位置上的感受野已经确定了，也就是它看到了什么区域已经非常明确了，让它去预测超过这个区域的目标，其实就不合理了。看到了但是能不能学好又是另一回事了。这个就和backbone的结构设计就有很大关系了。

**总结：backbone能为检测提供若干种感受野大小和中心步长的组合，以满足对不同尺度和类别的目标检测。**

## neck：Naiveneck\FPN\BiFPN\PANet\NAS-FPN

neck接受来自backbone的若干个特征图，处理后再输出给head。NaiveNeck：其实也就是没有neck，如SSD。

neck的第一要务就是进行特征融合：具有不同感受野大小的特征图进行了耦合，从而增强了特征图的表达能力。neck决定了head的数量，不同尺度的目标被分配到不同的Head学习，即：学习的负担被分散到了多个层级的特征图上。此外，进行宽带对齐，便于后续使用。

## head：RetinaNet-Head\FCOS-Head

划分方式1：有无Anchor：RetinaNet就是anchor-based，同时没有quality分支

划分方式2：有无quality分支：FCOS：anchor-free的，同时有quality分支







